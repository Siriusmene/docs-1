## Data Store Interface

The DataStore interface allows you to implement your own caching logic for Statsig configurations. This can be useful for:

- Reducing dependency on Statsig servers during initialization
- Improving initialization time by loading configurations from a local data store
- Providing fine-grained control over network I/O
- Ensuring reliability during temporary Statsig API outages

### Interface Definition

To implement a custom DataStore, create a class that inherits from `DataStoreBase` and implements the following methods:

```python
from statsig_python_core import DataStoreBase

class CustomDataStore(DataStoreBase):
    def get(self, key: str) -> dict:
        """
        Retrieve a value from the data store.
        
        Args:
            key: A string identifier for the value
            
        Returns:
            A dictionary containing:
                - result: Optional[str] - The stored value if found
                - time: Optional[int] - Unix timestamp of when the value was stored
        """
        # Implement custom get logic here
        return {"result": None, "time": None}
    
    def set(self, key: str, value: str, time: Optional[int] = None) -> None:
        """
        Store a value in the data store.
        
        Args:
            key: A string identifier for the value
            value: The string value to store
            time: Optional Unix timestamp to store with the value
        """
        # Implement custom set logic here
        pass
    
    def initialize(self) -> None:
        """
        Initialize the data store. Called when Statsig initializes.
        """
        # Implement custom initialization logic here
        pass
    
    def shutdown(self) -> None:
        """
        Clean up resources used by the data store. Called when Statsig shuts down.
        """
        # Implement custom shutdown logic here
        pass
        
    def support_polling_updates_for(self, path: str) -> bool:
        """
        Whether this data store should be used as the source of truth for the given path.
        
        Args:
            path: A string path identifier (e.g., "download_config_specs")
            
        Returns:
            True if this data store should be the source of truth for updates, False otherwise
        """
        # By default, return False to allow the SDK to poll Statsig for updates
        return False
```

### Example Implementation

Here's an example of a simple Redis-based DataStore implementation:

```python
from statsig_python_core import DataStoreBase, StatsigOptions, Statsig
import redis
import json
import time

class RedisDataStore(DataStoreBase):
    def __init__(self, host='localhost', port=6379, db=0):
        self.client = redis.Redis(host=host, port=port, db=db)
        
    def get(self, key: str) -> dict:
        value = self.client.get(key)
        timestamp = None
        
        if value:
            timestamp_bytes = self.client.get(f"{key}:timestamp")
            if timestamp_bytes:
                timestamp = int(timestamp_bytes.decode('utf-8'))
            
            return {
                "result": value.decode('utf-8'),
                "time": timestamp
            }
        
        return {"result": None, "time": None}
    
    def set(self, key: str, value: str, timestamp: int = None) -> None:
        self.client.set(key, value)
        
        if timestamp is None:
            timestamp = int(time.time())
            
        self.client.set(f"{key}:timestamp", str(timestamp))
    
    def initialize(self) -> None:
        # Verify connection is valid
        self.client.ping()
    
    def shutdown(self) -> None:
        self.client.close()
        
    def support_polling_updates_for(self, path: str) -> bool:
        # For this example, we'll let Statsig handle polling
        return False

# Using the custom data store
redis_store = RedisDataStore(host='redis.example.com')

options = StatsigOptions()
options.data_store = redis_store

statsig = Statsig("secret-key", options)
statsig.initialize().wait()
```

When used this way, the DataStore will be used to:
1. Load configurations during initialization if available
2. Store configurations after they're fetched from Statsig
3. Provide cached configurations if Statsig is temporarily unavailable

This ensures your application remains reliable even during temporary network issues or Statsig service outages.
