import GitHubEmbed from "@site/src/components/GitHubEmbed";

## Updating user properties (e.g., Login)

Sometimes you'll need to update user properties, say when the user logs in and a `userID` is assigned, or a set of new properties have been identified.  This would require Statsig to go fetch new values for all the gates, experiments and config evaluations.  This is achieved by the `useStatsigUser` hook:

```tsx
// RootPage.js
import { useGateValue, useStatsigUser } from "@statsig/react-bindings";

function RootPage() {
  const gateValue = useGateValue("check_user");
  const { updateUserAsync } = useStatsigUser();
  
  return (
    <div>
      <div>Gate is {gateValue ? 'passing' : 'failing'}.</div>
      <button onClick={() => updateUserAsync({ userID: "2" })}>
        Login
      </button>
    </div>
  );
}

export default RootPage;
```

## Deferring Initialization until user information is available
If your user information (identity, properties) become available on the webpage asyncronously after Statsig has loaded, you should consider defering initialization rather than initializating with an empty user object and calling updateUser later on.

You can implement a modified StatsigProvider that implements a useEffect hook that automatically handles user state mutations. 
This example will defer initialization until user object is defined, and then will automatically reinitialize Statsig and propogate gate/experiment state changes to child components any time the user object is updated.

```js
import React, { useEffect, useState } from "react"
import { Provider } from "statsig-react"
import { StatsigClient } from "statsig-js"

export const StatsigProvider = ({ children, value }) => {
  const [client, setClient] = useState<StatsigClient | null>(null)

  useEffect(() => {
    const user = {
      userID: value?.user?.id,
      custom: {
        isLoggedIn: value?.user ? "true" : "false",
      },
    }

    const newClient = new StatsigClient(
      process.env.STATSIG_CLIENT_SDK_KEY,
      user,
      {
        environment: { tier: process.env.RUNTIME_ENV }
      }
    )

    // Kick off async initialization, but don't wait
    newClient.initializeAsync().catch(console.error)

    // Set the client right away
    setClient(newClient)
  }, [value?.user])

  if (!client) {
    return null // or a loading UI if needed
  }

  return <Provider client={client}>{children}</Provider>
}
```